import { ILoadingScreen } from '@babylonjs/core/Loading/loadingScreen';
import { AbstractEngine, EngineStore, Nullable, Observer } from '@babylonjs/core';

export class TextLoadingScreen implements ILoadingScreen {
    private _engine: Nullable<AbstractEngine> = null;
    private _resizeObserver: Nullable<Observer<AbstractEngine>> = null;
    private _isLoading: boolean = false;
    /**
     * Maps a loading `HTMLDivElement` to a tuple containing the associated `HTMLCanvasElement`
     * and its `DOMRect` (or `null` if not yet available).
     */
    private _loadingDivToRenderingCanvasMap: Map<HTMLDivElement, [HTMLCanvasElement, DOMRect | null]> = new Map();
    private _loadingTextDiv: Nullable<HTMLDivElement> = null;

    /**
     * Creates a new default loading screen
     * @param _renderingCanvas defines the canvas used to render the scene
     * @param _loadingText defines the default text to display
     * @param _loadingDivBackgroundColor defines the default background color
     */
    constructor(
        private _renderingCanvas: HTMLCanvasElement,
        private _loadingText = "",
        private _loadingDivBackgroundColor = "black"
    ) {}

    /**
     * Function called to display the loading screen
     */
    public displayLoadingUI(): void {
        if (this._isLoading) {
            // Do not add a loading screen if it is already loading
            return;
        }

        this._isLoading = true;
        // get current engine by rendering canvas
        this._engine = EngineStore.Instances.find((engine) => engine.getRenderingCanvas() === this._renderingCanvas) as AbstractEngine;

        const loadingDiv = document.createElement("div");

        loadingDiv.id = "babylonjsLoadingDiv";
        loadingDiv.style.opacity = "0";
        loadingDiv.style.transition = "opacity 1.5s ease";
        loadingDiv.style.pointerEvents = "none";
        loadingDiv.style.display = "grid";
        loadingDiv.style.gridTemplateRows = "100%";
        loadingDiv.style.gridTemplateColumns = "100%";
        loadingDiv.style.justifyItems = "center";
        loadingDiv.style.alignItems = "center";

        // Loading text
        this._loadingTextDiv = document.createElement("div");
        this._loadingTextDiv.style.position = "absolute";
        this._loadingTextDiv.style.left = "0";
        this._loadingTextDiv.style.top = "50%";
        this._loadingTextDiv.style.marginTop = "0px";
        this._loadingTextDiv.style.width = "100%";
        this._loadingTextDiv.style.height = "20px";
        this._loadingTextDiv.style.fontFamily = "Arial";
        this._loadingTextDiv.style.fontSize = "32px";
        this._loadingTextDiv.style.color = "white";
        this._loadingTextDiv.style.textAlign = "center";
        this._loadingTextDiv.style.zIndex = "1";

        loadingDiv.appendChild(this._loadingTextDiv);

        //set the predefined text
        this._loadingTextDiv.innerHTML = this._loadingText;

        loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
        loadingDiv.style.opacity = "1";

        const canvases: Array<HTMLCanvasElement> = [];
        const views = this._engine.views;
        if (views?.length) {
            for (const view of views) {
                if (view.enabled) {
                    canvases.push(view.target);
                }
            }
        } else {
            canvases.push(this._renderingCanvas);
        }
        for (let i = 0; i < canvases.length; i++) {
            const canvas = canvases[i];
            const clonedLoadingDiv = loadingDiv!.cloneNode(true) as HTMLDivElement;
            clonedLoadingDiv.id += `-${i}`;
            this._loadingDivToRenderingCanvasMap.set(clonedLoadingDiv, [canvas, null]);
        }

        this._resizeLoadingUI();

        this._resizeObserver = this._engine.onResizeObservable.add(() => {
            this._resizeLoadingUI();
        });

        this._loadingDivToRenderingCanvasMap.forEach((_, loadingDiv) => {
            document.body.appendChild(loadingDiv);
        });
    }

    /**
     * Function called to hide the loading screen
     */
    public hideLoadingUI(): void {
        if (!this._isLoading) {
            return;
        }

        let completedTransitions = 0;

        const onTransitionEnd = (event: TransitionEvent) => {
            const loadingDiv = event.target as HTMLDivElement;
            // ensure that ending transition event is generated by one of the current loadingDivs
            const isTransitionEndOnLoadingDiv = this._loadingDivToRenderingCanvasMap.has(loadingDiv);

            if (isTransitionEndOnLoadingDiv) {
                completedTransitions++;
                loadingDiv.remove();

                const allTransitionsCompleted = completedTransitions === this._loadingDivToRenderingCanvasMap.size;
                if (allTransitionsCompleted) {
                    if (this._loadingTextDiv) {
                        this._loadingTextDiv.remove();
                        this._loadingTextDiv = null;
                    }

                    window.removeEventListener("transitionend", onTransitionEnd);
                    this._engine!.onResizeObservable.remove(this._resizeObserver);
                    this._loadingDivToRenderingCanvasMap.clear();
                    this._engine = null;
                    this._isLoading = false;
                }
            }
        };

        this._loadingDivToRenderingCanvasMap.forEach((_, loadingDiv) => {
            loadingDiv.style.opacity = "0";
        });

        window.addEventListener("transitionend", onTransitionEnd);
    }

    /**
     * Gets or sets the text to display while loading
     */
    public set loadingUIText(text: string) {
        this._loadingText = text;

        if (this._loadingTextDiv) {
            this._loadingDivToRenderingCanvasMap.forEach((_, loadingDiv) => {
                // set loadingTextDiv of current loadingDiv
                loadingDiv.children[0].innerHTML = this._loadingText;
            });
        }
    }

    public get loadingUIText(): string {
        return this._loadingText;
    }

    /**
     * Gets or sets the color to use for the background
     */
    public get loadingUIBackgroundColor(): string {
        return this._loadingDivBackgroundColor;
    }

    public set loadingUIBackgroundColor(color: string) {
        this._loadingDivBackgroundColor = color;

        if (!this._isLoading) {
            return;
        }

        this._loadingDivToRenderingCanvasMap.forEach((_, loadingDiv) => {
            loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
        });
    }

    /**
     * Checks if the layout of the canvas has changed by comparing the current layout
     * rectangle with the previous one.
     *
     * This function compares of the two `DOMRect` objects to determine if any of the layout dimensions have changed.
     * If the layout has changed or if there is no previous layout (i.e., `previousCanvasRect` is `null`),
     * it returns `true`. Otherwise, it returns `false`.
     *
     * @param previousCanvasRect defines the previously recorded `DOMRect` of the canvas, or `null` if no previous state exists.
     * @param currentCanvasRect defines the current `DOMRect` of the canvas to compare against the previous layout.
     * @returns `true` if the layout has changed, otherwise `false`.
     */
    private _isCanvasLayoutChanged(previousCanvasRect: DOMRect | null, currentCanvasRect: DOMRect) {
        return (
            !previousCanvasRect ||
            previousCanvasRect.left !== currentCanvasRect.left ||
            previousCanvasRect.top !== currentCanvasRect.top ||
            previousCanvasRect.right !== currentCanvasRect.right ||
            previousCanvasRect.bottom !== currentCanvasRect.bottom ||
            previousCanvasRect.width !== currentCanvasRect.width ||
            previousCanvasRect.height !== currentCanvasRect.height ||
            previousCanvasRect.x !== currentCanvasRect.x ||
            previousCanvasRect.y !== currentCanvasRect.y
        );
    }

    // Resize
    private _resizeLoadingUI = () => {
        if (!this._isLoading) {
            return;
        }

        this._loadingDivToRenderingCanvasMap.forEach(([canvas, previousCanvasRect], loadingDiv) => {
            const currentCanvasRect = canvas.getBoundingClientRect();
            if (this._isCanvasLayoutChanged(previousCanvasRect, currentCanvasRect)) {
                const canvasPositioning = window.getComputedStyle(canvas).position;

                loadingDiv.style.position = canvasPositioning === "fixed" ? "fixed" : "absolute";
                loadingDiv.style.left = currentCanvasRect.left + window.scrollX + "px";
                loadingDiv.style.top = currentCanvasRect.top + window.scrollY + "px";
                loadingDiv.style.width = currentCanvasRect.width + "px";
                loadingDiv.style.height = currentCanvasRect.height + "px";

                this._loadingDivToRenderingCanvasMap.set(loadingDiv, [canvas, currentCanvasRect]);
            }
        });
    };
}